/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_xue_song_ffmpeg_FPlayer.h"
#include <android/log.h>
#include "ffmpeg/libavutil/avutil.h"
#include "ffmpeg/libavutil/frame.h"
#include "ffmpeg/libavformat/avformat.h"
#include "ffmpeg/libswscale/swscale.h"
#include "ffmpeg/libavcodec/avcodec.h"
/* Header for class com_xue_song_ffmpeg_FPlayer */
#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,"wang",__VA_ARGS__)
#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,"wang",__VA_ARGS__)

JNIEXPORT void JNICALL Java_com_xue_song_ffmpeg_FPlayer_doOutput
        (JNIEnv *env, jclass jcl, jstring jstr_input, jstring jstr_oupt) {
    const char *input_c = (*env)->GetStringUTFChars(env, jstr_input, NULL);
    const char *output_c = (*env)->GetStringUTFChars(env, jstr_oupt, NULL);
    LOGI("input %s  output %s", input_c, output_c);
    //注册所有组件
    av_register_all();
    //封装格式上下文，统领全局的结构体，保存视频文件的封装格式的相关信息
    AVFormatContext *avFormatContext = avformat_alloc_context();
    //打开输入文件
    if (avformat_open_input(&avFormatContext, input_c, NULL, NULL) != 0) {
        LOGE("%s", "打开 输入文件失败");
        return;
    }
    //获取文件信息
    if (avformat_find_stream_info(avFormatContext, NULL) < 0) {
        LOGE("%s", "获取文件信息失败");
        return;
    }
    int v_stream_idx = -1;
    int i = 0;
    // 拿到视频的脚标
    for (; i < avFormatContext->nb_streams; i++) {
        if (avFormatContext->streams[i]->codec->codec_type== AVMEDIA_TYPE_VIDEO) {
            v_stream_idx = i;
            break;
        }
    }
    if (v_stream_idx == -1) {
        LOGE("%s", "not find vedio stream");
        return;
    }
    //拿到编解码上下文
    AVCodecContext *avCodecContext = avFormatContext->streams[i]->codec;
    //拿到编解码器
    AVCodec *avCodec = avcodec_find_decoder(avCodecContext->codec_id);
    if (avCodec == NULL) {
        LOGE("%s", "not find decoder");
        return;
    }
    if (avcodec_open2(avCodecContext, avCodec, NULL) != 0) {
        LOGE("%s", "decoder can not open");
        return;
    }
    LOGI("file format: %s", avFormatContext->iformat->name);
    LOGI("vedio long:%ld", (avFormatContext->duration) / 1000000);
    LOGI("with :%d height:%d", avCodecContext->width, avCodecContext->height);
    LOGI("decoder name :%s", avCodec->name);
    //准备读取帧数据
    //用于存储一帧一帧压缩数据
    AVPacket *avPacket = av_malloc(sizeof(AVPacket));
    //用于存储 解码后的数据
    AVFrame *avFrame = av_frame_alloc();
    //用于存储转码后的yuv 数据
    AVFrame *avFrameYuv = av_frame_alloc();
    u_int8_t *out_buffer = av_malloc(
            avpicture_get_size(AV_PIX_FMT_YUV420P, avCodecContext->width, avCodecContext->height));
    //初始化 缓冲区
    avpicture_fill((AVPicture *) avFrame, out_buffer, AV_PIX_FMT_YUV420P, avCodecContext->width,
                   avCodecContext->height);
    //获取转码 上下文
    struct SwsContext *swsContext = sws_getContext(avCodecContext->width, avCodecContext->height,
                                                   avCodecContext->pix_fmt,
                                                   avCodecContext->width, avCodecContext->height,
                                                   AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL,
                                                   NULL);
    int got_picture, ret;

    FILE *file = fopen(output_c, "wb+");
    int frameNum = 0;
    //一帧一帧读取压缩数据
    while (av_read_frame(avFormatContext, avPacket)) {

        ret = avcodec_decode_video2(avCodecContext, avFrame, &got_picture, avPacket);
        if (ret == -1) {
            LOGE("%s", "decoder error");
        }
        if (got_picture) {
            sws_scale(swsContext, avFrame->data, avFrame->linesize, 0, avCodecContext->height,
                      avFrameYuv->data, avFrameYuv->linesize);
            int size = avCodecContext->width * avCodecContext->height;
            fwrite(avFrameYuv->data[0], 1, size, file);
            fwrite(avFrameYuv->data[1], 1, size / 4, file);
            fread(avFrameYuv->data[2], 1, size / 4, file);
            LOGI("帧数%d", frameNum);
        }
        av_free_packet(avPacket);
    }
    av_frame_free(&avFrame);
    avcodec_close(avCodecContext);
    avformat_free_context(avFormatContext);
}

